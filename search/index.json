[{"content":"在新手时期不知道哪里抄来的代码，在低并发的时候没事，在高并发的下出问题了，浪费了不少时间记录下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class JsonTypeHandler\u0026lt;T extends Object\u0026gt; extends BaseTypeHandler\u0026lt;T\u0026gt; { // ... 其他代码省略 private static final PGobject jsonObject = new PGobject(); public JsonTypeHandler() { } @Override public void setNonNullParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException { jsonObject.setType(\u0026#34;json\u0026#34;); ObjectMapper mapper = new ObjectMapper(); // ... 省略其他操作 ps.setObject(i, jsonObject); } // ... 省略其他方法 } 在上面的代码中，创建了一个静态的PGobject对象jsonObject，并在setNonNullParameter方法中对其进行操作。然而，静态变量在多线程环境中可能会导致线程安全问题，因为多个线程可能会同时访问和修改这个静态变量。\n解决方法是将PGobject对象的创建和操作放在setNonNullParameter方法内部，这样每次调用setNonNullParameter方法时都会创建一个新的PGobject对象，避免多线程共享同一个对象导致的线程安全问题。\n","date":"2023-11-10T00:00:00Z","permalink":"https://blog.franz1024.com/p/pg-mybatis%E4%B8%AD%E4%BD%BF%E7%94%A8typehandler%E5%AF%BC%E8%87%B4json%E5%AD%97%E6%AE%B5%E5%BC%82%E5%B8%B8%E8%B5%8B%E5%80%BC%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","title":"PG \u0026\u0026 MyBatis中使用TypeHandler导致json字段异常赋值的线程安全问题"},{"content":"在使用PostgreSQL数据库时，有时候我们需要清空表中的数据，以便重新插入新的数据或者进行其他操作。本文将介绍在PostgreSQL中清空表的几种方法。\n使用DELETE语句 最简单的方法是使用DELETE语句来清空表中的数据。例如，如果我们有一个名为users的表，我们可以使用以下语句来清空表中的数据：\n1 DELETE FROM users; 这将删除users表中的所有数据，但是保留表的结构和约束。\n使用TRUNCATE语句 另一种常用的方法是使用TRUNCATE语句来清空表中的数据。与DELETE不同的是，TRUNCATE语句将表中的数据全部删除，并且重置自增的序列。例如：\n1 TRUNCATE TABLE users; 需要注意的是，TRUNCATE语句比DELETE语句更快，因为它不会逐条删除数据，而是直接删除整个表。但是，TRUNCATE语句无法触发ON DELETE触发器，所以在使用TRUNCATE时需要注意。\n使用DROP和CREATE语句 最彻底的方法是使用DROP和CREATE语句来删除表并重新创建一个空表。例如：\n1 2 3 4 5 DROP TABLE users; CREATE TABLE users ( id SERIAL PRIMARY KEY, name VARCHAR(100) ); 这种方法将删除表的结构和约束，然后重新创建一个空表。\n清空表的方法有多种，可以根据具体情况选择合适的方法。在进行数据操作时，需要谨慎选择，以免造成不必要的损失。希望本文对你有所帮助！\n","date":"2023-11-10T00:00:00Z","permalink":"https://blog.franz1024.com/p/postgresql%E6%B8%85%E7%A9%BA%E6%95%B0%E6%8D%AE%E8%A1%A8/","title":"PostgreSQL清空数据表"},{"content":"因为Kafka依赖于zookeeper做分布式管理，因此需要先安装zookeeper\nzookeeper启动\n1 2 docker run -d --name zookeeper -p 2181:2181 \\ -t wurstmeister/zookeeper kafka启动\n1 2 3 4 5 docker run -d --name kafka -p 9092:9092 -e KAFKA_BROKER_ID=0 \\ -e KAFKA_ZOOKEEPER_CONNECT=124.223.***.176:2181 \\ -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://124.223.***.176:9092 \\ -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 \\ -t wurstmeister/kafka ","date":"2023-11-10T00:00:00Z","permalink":"https://blog.franz1024.com/p/%E9%83%A8%E7%BD%B2%E7%AE%80%E6%98%93kafka%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/","title":"部署简易Kafka测试环境"},{"content":" 生成一个 admin 用户管理页面的 token\n1 openssl rand -base64 48 使用docker部署\n1 2 3 4 5 6 7 8 9 docker run -d --name vaultwarden \\ -e SIGNUPS_ALLOWED=false \\ -e INVITATIONS_ALLOWED=false \\ -e ADMIN_TOKEN=上面生成得Base64 \\ -e LOG_FILE=/data/log.log \\ -e LOG_LEVEL=info \\ -p 8081:80 \\ -v /root/vaultwarden/:/data/ \\ vaultwarden/server:latest 对bitwarden进行定时备份\n按照官方说明，现执行 docker 镜像，获取 token。这里的镜像一大部分都是 Rclone。\n1 2 3 docker run –rm -it \\ –mount type=volume,source=vaultwarden-rclone-data,target=/config/ \\ ttionya/vaultwarden-backup:latest rclone config 配置Rclone\n执行备份定时备份的docker容器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 七牛云 docker 备份配置,这里仅参考，正式备份内容见下方备份到多个位置 docker run -d \\ --restart=always \\ --name vaultwarden_backup_qiniu \\ --volumes-from=vaultwarden \\ --mount type=volume,source=vaultwarden-rclone-data,target=/config/ \\ -e DATA_DIR=\u0026#34;/data\u0026#34; \\ -e RCLONE_REMOTE_NAME=BitwardenBackup_qiniu \\ -e RCLONE_REMOTE_DIR=\u0026#34;bitwarden-1024\u0026#34; \\ -e ZIP_TYPE=\u0026#34;7z\u0026#34; \\ -e CRON=\u0026#34;0 */8 * * *\u0026#34; \\ -e ZIP_PASSWORD=\u0026#34;压缩密码\u0026#34; \\ -e BACKUP_KEEP_DAYS=\u0026#34;30\u0026#34; \\ ttionya/vaultwarden-backup:latest 从备份中还原\n停止bitwarden容器\n还原命令\n1 2 3 4 5 6 7 docker run --rm -it \\ --mount type=bind,source=\u0026#34;/root/vaultwarden\u0026#34;,target=/data/ \\ --mount type=bind,source=$(pwd),target=/bitwarden/restore/ \\ -e DATA_DIR=\u0026#34;/data\u0026#34; \\ ttionya/vaultwarden-backup:latest restore \\ --zip-file 文件名称 \\ -p 压缩密码 启动bitwarden容器\n","date":"2023-11-20T10:22:37Z","permalink":"https://blog.franz1024.com/post/bitwarden-z65ahd.html","title":"Bitwarden部署与备份"},{"content":"1.利用 linux 进程管理重启 1 ps -ef|grep nginx 将会列出 nginx 相关的进程号，如下所示\n1 2 3 4 5 root@ubuntu:~# ps -ef|grep nginx root 1773 1 0 May12 ? 00:00:00 nginx: master process nginx nginx 22672 1773 0 01:58 ? 00:00:00 nginx: worker process nginx 22673 1773 0 01:58 ? 00:00:00 nginx: worker process root 23617 20075 0 02:29 pts/1 00:00:00 grep --color=auto nginx 之后再用 kil 命令即可终止 nginx 进程，再重新执行 nginx 即可\n1 kill -9 pid 也可以多个同时终止\n1 kill -9 1773 22672 这样比较麻烦，而且这个过程中会中断服务的提供。那么有没有热配置，或者是不重启就可以生效呢？\n答案当然是有的。那就是使用 nginx -s reload 命令。\n2. nginx -s reload s 代表的是向主进程发送信号。其中信号有 4 个，stop, quit, reopen, reload。\nreload 就是重新加载的意思。nginx -s reload​ 命令，合起来的作用就是重新加载配置文件。使用此命令可以做到无缝切换服务\n注意事项\n​nginx -s reload​ 是平滑重启,不会强制结束正在工作的连接,需要等所有连接都结束才会重启。 强烈建议在使用 nginx -s reload​时使用 nginx -t​检查配置文件是否正确 ‍\n","date":"2023-10-26T17:17:03Z","permalink":"https://blog.franz1024.com/post/nginx-restart-method-and-precautions-zyhlkb.html","title":"Nginx重启的方法以及注意事项"},{"content":"1.nohub 命令 ​nohup​英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。 英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。\n​nohup​命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out​ 文件中。 文件中。\n使用权限 所有使用者所有使用者\n语法格式 1 nohup Command [ Arg … ] [　\u0026amp; ] 参数说明： Command​ ：要执行的命令。 ：要执行的命令。\nArg​ ：一些参数，可以指定输出文件。 ：一些参数，可以指定输出文件。\n\u0026amp;​ ：让命令在后台执行，终端退出后命令仍旧执行。 ：让命令在后台执行，终端退出后命令仍旧执行。\n实例 以下命令在后台执行当前目录下的java程序以下命令在后台执行当前目录下的java程序\n1 nohup java -jar ***.jar \u0026amp; 这时我们打开 root 目录 可以看到生成了 nohup.out 文件。 这时我们打开 root 目录 可以看到生成了 nohup.out 文件。\n如果要停止运行，你需要使用以下命令查找到 nohup 运行脚本到 PID，然后使用 kill 命令来删除： 如果要停止运行，你需要使用以下命令查找到 nohup 运行脚本到 PID，然后使用 kill 命令来删除：\n1 ps -aux | grep \u0026#34;***.jar\u0026#34; 参数说明： 参数说明：\na​ : 显示所有程序 : 显示所有程序 u​ : 以用户为主的格式来显示 : 以用户为主的格式来显示 x​ : 显示所有程序，不区分终端机 : 显示所有程序，不区分终端机 另外也可以使用 另外也可以使用 ps -def | grep \u0026quot;runoob.sh​ \u0026quot; 命令来查找。 \u0026quot; 命令来查找。\n找到 PID 后，就可以使用 kill PID 来删除。 找到 PID 后，就可以使用 kill PID 来删除。\n1 kill -9 进程号PID 以下命令在后台执行 root 目录下的 以下命令在后台执行 root 目录下的 runoob.sh 脚本，并重定向输入到 runoob.log 文件：\n1 nohup java -jar \u0026lt;span style=\u0026#34;font-weight: bold;\u0026#34; data-type=\u0026#34;strong\u0026#34;\u0026gt;*.jar \u0026gt; \u0026lt;/span\u0026gt;*.log 2\u0026gt;\u0026amp;1 \u0026amp; 2\u0026gt;\u0026amp;1 解释：\n将标准错误 2 重定向到标准输出 \u0026amp;1 ，标准输出 \u0026amp;1 再被重定向输入到 ***.log 文件中。\n0 – stdin (standard input，标准输入) 1 – stdout (standard output，标准输出) 2 – stderr (standard error，标准错误输出) 2.screen 命令 ​screen​ 是一个在 Unix 和 Unix-like 操作系统中使用的终端复用工具，它允许用户在一个终端窗口中同时运行多个独立的终端会话。这个工具非常有用，因为它可以帮助您在同一个终端窗口中运行多个任务，而不必打开多个终端窗口。以下是一些常见的 screen​ 命令和用法：\n启动 ​screen​ 会话​ ：\n1 screen 运行这个命令后，您将进入一个新的 screen​ 会话。在这个会话中，您可以执行命令，运行程序，然后将其分离（detach）以后台运行。\n分离 ​screen​ 会话​ ：\n在 screen​ 会话中，您可以使用以下组合键将会话分离到后台：Ctrl-a\n这将让 screen​ 会话继续在后台运行，而您可以回到原来的终端窗口。\n列出 ​screen​ 会话​ ：\n要列出当前的 screen​ 会话，您可以运行以下命令：\n1 screen -ls 这将显示当前运行的 screen​ 会话的列表。\n重新连接到 ​screen​ 会话​ ：\n要重新连接到以前分离的 screen​ 会话，使用以下命令，其中 \u0026lt;session_name\u0026gt; ​ 是您要重新连接的会话的名称或 ID：\n1 screen -r \u0026lt;session_name\u0026gt; 创建具有自定义名称的 ​screen​ 会话​ ：\n您可以使用以下命令创建一个具有自定义名称的 screen​ 会话：\n1 screen -S \u0026lt;session_name\u0026gt; 这将创建一个新的 screen​ 会话并为其指定名称。\n结束 ​screen​ 会话​ ：\n要结束 screen​ 会话，可以在会话中运行 exit​ 命令，或者按下 Ctrl-d​ 。\n帮助​ ：\n如果需要查看更多 screen​ 的命令和选项，可以在 screen​ 会话中按下 Ctrl-a ? ​，这将显示帮助信息。\n​screen​ 是一个非常强大的工具，特别适合在 SSH 连接中管理多个任务或会话。您可以在 screen​ 会话中运行长时间运行的进程，然后分离会话，以便在稍后重新连接并查看输出。这对于远程服务器管理和维护非常有用。\n‍\n","date":"2023-10-26T16:27:56Z","permalink":"https://blog.franz1024.com/post/linux-background-running-and-viewing-the-background-process-method-zhs2a7.html","title":"Linux后台运行和查看后台进程的方法"}]